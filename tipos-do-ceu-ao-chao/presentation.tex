\documentclass{beamer}

\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{listings}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=red,
}

\usetheme{Hannover}
\usecolortheme{crane}

\newcommand{\nota}[1]{\textbf{Nota:}\textit{ #1}}

\title{Tipos do Céu ao Chão}
\author{Hashimoto}
\date{17 de Junho de 2022}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}
    \frametitle{ToC}
    \tableofcontents[hideallsubsections]
\end{frame}

\section{Tipos}
\begin{frame}
    \frametitle{Intro}
\end{frame}

\begin{frame}
    \frametitle{Notação}
\end{frame}

\section{Tipos - Caso Recursivo}
\subsection{Produto}
\begin{frame}
    \frametitle{Produto \(A \times B\)}
    \begin{itemize}
        \item Construtor
            \[
                A \to B \to A \times B
            \]
        \item Destrutor
            \[
                A \times B \to (A \to B \to C) \to C
            \]
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: \(A \times B\)}
    \begin{itemize}
        \item C:
        \begin{lstlisting}[language=C]
struct produto {
    int A;
    int B;
};
        \end{lstlisting}
        \item Java:
        \begin{lstlisting}[language=Haskell]
class Produto {
    private int A;
    private int B;
}
        \end{lstlisting}
        \item Haskell:
        \begin{lstlisting}[language=Haskell]
data Produto = P { a :: Int, b :: Int }
        \end{lstlisting}
    \end{itemize}
\end{frame}

\subsection{Soma}
\begin{frame}
    \frametitle{Soma \(A + B\)}
    \begin{itemize}
        \item Construtores
            \[
                left : A \to A + B
            \]
            \[
                right : B \to A + B
            \]
        \item Destrutor
            \[
                A + B \to (A \to C) \to (B \to C) \to C
            \]
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Exemplos: \(A + B\)}
\end{frame}

\subsection{Exponencial}
\begin{frame}
    \frametitle{Exponencial \(B^A\)}
    \begin{itemize}
        \item Construtor
            \[
                (A \to B) \to B^A
            \]
        \item Destrutor
            \[
                eval : B^A \to (A \to B)
            \]
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Exemplos: \(B^A\)}
\end{frame}

\subsection{Tipos Algébricos}
\begin{frame}[fragile]
    \frametitle{Tipos Algébricos}
    \begin{lstlisting}[language=Haskell]
data TipoAlg
  = Caso1 A B C
  | Caso2
  | Caso3 F
    \end{lstlisting}
\end{frame}

\section{Tipos - Casos Base}
\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\subsection{Unity}
\begin{frame}
    \frametitle{\(()\)}
\end{frame}

\subsection{Void}
\begin{frame}
    \frametitle{\(Void\)}
\end{frame}

\subsection{Bool}
\begin{frame}
    \frametitle{Bool}
\end{frame}

\subsection{Int}
\begin{frame}
    \frametitle{I32}
\end{frame}

\section{Tipos Paramétricos}
\begin{frame}
    \frametitle{Tipos Paramétricos}
    Outros nomes:
    \begin{itemize}
        \item Generics [Java]
        \item Macros (*) [C]
        \item Meta Programming (Comptime) [Zig]
        \item Templates (typename) [C++]
    \end{itemize}
\end{frame}

\subsection{Maybe}
\begin{frame}
    \frametitle{Maybe a}
\end{frame}

\subsection{Either}
\begin{frame}
    \frametitle{Either a b}
\end{frame}

\subsection{List}
\begin{frame}
    \frametitle{[a]}
\end{frame}

\begin{frame}[fragile]
    \frametitle{int *p = \&i;}
    \begin{lstlisting}[language=Haskell]
Pointer a = Null
    | Estrela  a
    | Colchete [a]
    \end{lstlisting}
    \vfill
    Problemas (teóricos) dessa representação:
    \begin{itemize}
        \item
            \texttt{C} não sabe diferenciar
            \texttt{Estrela} e \texttt{Colchete}
        \item
            Temos que checar se é \texttt{Null} o tempo todo
        \item
            \textbf{Invisível:} no caso \texttt{Colchete},
            podemos não saber o tamanho da lista
            \par
            \nota{ainda podemos ter o ``null terminator''
            ou guardar um tamanho externo}
        \item
            Na prática, só queremos usar
            \texttt{Estrela} ou \texttt{Colchete}
            \par
            \nota{o ``ou'' é exclusivo}
        \item
            Mais alguns (específicos sobre implementação) \dots
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Soluções: Zig}
    \begin{lstlisting}[language=C]
const OptionalInt = ?i32;

const PtrToOneInt = *i32;

const PtrToManyInt = [*]i32;

const NullablePtrToOneInt = ?*i32;

const PtrToOneOptionalInt = *?i32;

const NullablePtrToManyInt = ?[*]i32;

const PtrToManyOptionalInt = [*]?i32;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Outros: Zig}
    \begin{lstlisting}[language=C]
// struct { len : usize, data : [*]i32, };
const Slice = []i32;

// Tem valores no array ate achar um A
// A eh um valor de i32
const Sentinel = [*:A]i32;

const CharStar = [*:0]u8;
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Implementação (Tipos Paramétricos)}
\end{frame}

\section{Classes de Tipos}
\begin{frame}
    \frametitle{Classes de Tipos}
    Outros nomes:
    \begin{itemize}
        \item Concepts [C++20]
        \item Interface [Go, Java, Kotlin, TypeScript]
        \item Module System [Standard ML]
        \item Mixin (?) [Ruby]
        \item Protocol [Erlang, Elixir, Swift]
        \item Typeclasses [Haskell]
        \item TypeTraits (?) [C++/Boost]
        \item Type Constrains [D]
        \item Traits [Rust]
        \item Vtable/Function Pointers [C, C++, Zig]
    \end{itemize}
    \vfill
    ``Concepts vs Typeclasses vs Traits vs Protocols''
    \url{youtu.be/E-2y1qHQvTg}
\end{frame}

\subsection{Monoid}
\begin{frame}
    \frametitle{Monoid}
\end{frame}

\subsection{Funtores}
\begin{frame}
    \frametitle{Funtores}
\end{frame}

\subsection{Monad}
\begin{frame}
    \frametitle{Monad}
\end{frame}

\begin{frame}
    \frametitle{Implementação (Classe de Tipos)}
\end{frame}

\section{Outros Tipos}
\begin{frame}
    \frametitle{Outros Tipos (Fora do escopo)}
\end{frame}

\subsection{Tipos Dependentes}
\begin{frame}
    \frametitle{Tipos Dependentes}
\end{frame}

\subsection{Tipos Lineares}
\begin{frame}
    \frametitle{Tipos Lineares}
\end{frame}

\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\begin{frame}
    \frametitle{FIM}
\end{frame}

\end{document}

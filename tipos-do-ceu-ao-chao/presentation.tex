\documentclass{beamer}

\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{listings}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=red,
}

\usepackage{multicol}

\usetheme{Hannover}
\usecolortheme{crane}

\newcommand{\lang}[1]{\texttt{#1}}
\newcommand{\inlcode}[1]{\texttt{#1}}

\newcommand{\nota}[1]{\textbf{Nota:}\textit{ #1}}

\newcommand{\tabelasizealign}{%
    \begin{tabular}{|c|c|c|}%
        \hline%
        Tipo & sizeof & alignment \\\hline%
        \hline%
        bool & 1      & 1         \\\hline%
        u32  & 4      & 4         \\\hline%
        u64  & 8      & 8         \\\hline%
    \end{tabular}%
}

\title{Tipos do Céu ao Chão}
\author{Hashimoto}
\date{17 de Junho de 2022}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}
    \frametitle{ToC}
    \tableofcontents[hideallsubsections]
\end{frame}

\section{Tipos}
\begin{frame}
    \frametitle{Intro}
\end{frame}

\begin{frame}
    \frametitle{Notação}
\end{frame}

\section{Tipos - Caso Recursivo}
\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\subsection{Produto}
\begin{frame}
    \frametitle{Produto \(A \times B\)}
    \begin{itemize}
        \item Construtor
            \[
                A \to B \to A \times B
            \]
        \item Destrutor
            \[
                A \times B \to (A \to B \to C) \to C
            \]
        \item Valores
            \[
                @(A \times B) = @(A) \times @(B)
            \]
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: \(A \times B\)}
    \begin{itemize}
        \item \lang{C} \emph{(struct)}:
            \begin{lstlisting}[language=C]
struct ProdutoIntDouble {
    int a;
    double b;
};
            \end{lstlisting}
        \item \lang{Java} \emph{(class)} (*):
            \begin{lstlisting}[language=Java]
class ProdutoIntDouble {
    private int a;
    private double b;
}
            \end{lstlisting}
        \item \lang{Haskell} \emph{(record)}:
            \begin{lstlisting}[language=Haskell]
data ProdutoIntDouble = PIntDouble
    { a :: Int
    , b :: Double
    }
            \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Matemática de Struct}
    Informações importantes de uma \emph{struct}:
    \begin{itemize}
        \item Tamanho \emph{(sizeof)}:
            quantos bytes ocupa?
        \item Alinhamento \emph{(alignment)}:
            endereço é múltiplo de quanto?
    \end{itemize}
    \vfill
    \nota{Nem sempre o \emph{tamanho final}
        é a soma dos \emph{tamanhos}!}
    \vfill
    Alinhamento:
    \url{www.delftstack.com/howto/c/struct-alignment-in-c/}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: Matemática de Struct}
    \begin{multicols}{2}
        \begin{lstlisting}[language=C]
struct Exemplo1 {
    u32 a;
    u32 b;
};
        \end{lstlisting}
        \begin{lstlisting}[language=C]
struct Exemplo2 {
    u32 a;
    bool b;
};
        \end{lstlisting}
        \begin{lstlisting}[language=C]
struct Exemplo3 {
    u64 a;
    u32 b;
    u32 c;
};
        \end{lstlisting}
        \columnbreak
        \begin{lstlisting}[language=C]
struct Exemplo4 {
    u32 b;
    u64 a;
    u32 c;
};
        \end{lstlisting}
        \begin{lstlisting}[language=C]
struct Exemplo5 {
    u32 b; u32 pad1;
    u64 a;
    u32 c; u32 pad2;
};
        \end{lstlisting}
        \tabelasizealign{}
    \end{multicols}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Respostas: Matemática de Struct}
    \begin{center} \begin{tabular}{|c|c|c||c|}
        \hline%
        Tipo      & sizeof & alignment & waste \\\hline
        \hline
        bool      & 1      & 1         & 0     \\\hline
        u32       & 4      & 4         & 0     \\\hline
        u64       & 8      & 8         & 0     \\\hline
        \hline
        Exemplo1  & 8      & 4         & 0     \\\hline
        Exemplo2  & 8      & 4         & 3     \\\hline
        Exemplo3  & 16     & 8         & 0     \\\hline
        Exemplo4  & 24     & 8         & 8     \\\hline
        Exemplo5  & 24     & 8         & 0     \\\hline
    \end{tabular} \end{center}
\end{frame}

\subsection{Soma}
\begin{frame}
    \frametitle{Soma \(A + B\)}
    \begin{itemize}
        \item Construtores
            \[
                left : A \to A + B
            \]
            \[
                right : B \to A + B
            \]
        \item Destrutor
            \[
                A + B \to (A \to C) \to (B \to C) \to C
            \]
        \item Valores
            \[
                @(A + B) = @(A) + @(B)
            \]
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Unions}
    \begin{lstlisting}[language=C]
union soma {
    int a;
    float b;
    char c;
};
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Enums}
\end{frame}

\begin{frame}
    \frametitle{Tagged Unions}
\end{frame}

\begin{frame}
    \frametitle{Matemática de Tagged Union}
\end{frame}

\begin{frame}
    \frametitle{Exemplos: \(A + B\)}
\end{frame}

\subsection{Exponencial}
\begin{frame}
    \frametitle{Exponencial \(B^A\)}
    \begin{itemize}
        \item Construtor
            \[
                (A \to B) \to B^A
            \]
        \item Destrutor
            \[
                eval : B^A \to (A \to B)
            \]
        \item Valores
            \[
                @(B^A) = @(B)^{@(A)}
            \]
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Exemplos: \(B^A\)}
\end{frame}

\subsection{Tipos Algébricos}
\begin{frame}[fragile]
    \frametitle{Tipos Algébricos}
    \begin{lstlisting}[language=Haskell]
data TipoAlg
  = Caso1 A B C
  | Caso2
  | Caso3 F
    \end{lstlisting}
\end{frame}

\section{Tipos - Casos Base}
\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\subsection{Unity}
\begin{frame}
    \frametitle{\(()\)}
\end{frame}

\subsection{Void}
\begin{frame}
    \frametitle{\(Void\)}
\end{frame}

\subsection{Bool}
\begin{frame}
    \frametitle{Bool}
\end{frame}

\subsection{Int}
\begin{frame}
    \frametitle{I32}
\end{frame}

\section{Tipos Paramétricos}
\begin{frame}
    \frametitle{Tipos Paramétricos}
    Outros nomes:
    \begin{itemize}
        \item Generics [Java]
        \item Macros (*) [C]
        \item Meta Programming (Comptime) [Zig]
        \item Templates (typename) [C++]
    \end{itemize}
\end{frame}

\subsection{Maybe}
\begin{frame}
    \frametitle{Maybe a}
\end{frame}

\subsection{Either}
\begin{frame}
    \frametitle{Either a b}
\end{frame}

\subsection{List}
\begin{frame}
    \frametitle{[a]}
\end{frame}

\begin{frame}[fragile]
    \frametitle{int *p = \&i;}
    \begin{lstlisting}[language=Haskell]
Pointer a = Null
    | Estrela  a
    | Colchete [a]
    \end{lstlisting}
    \vfill
    Problemas (teóricos) dessa representação:
    \begin{itemize}
        \item
            \texttt{C} não sabe diferenciar
            \texttt{Estrela} e \texttt{Colchete}
        \item
            Temos que checar se é \texttt{Null} o tempo todo
        \item
            \textbf{Invisível:} no caso \texttt{Colchete},
            podemos não saber o tamanho da lista
            \par
            \nota{ainda podemos ter o ``null terminator''
            ou guardar um tamanho externo}
        \item
            Na prática, só queremos usar
            \texttt{Estrela} ou \texttt{Colchete}
            \par
            \nota{o ``ou'' é exclusivo}
        \item
            Mais alguns (específicos sobre implementação) \dots
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Soluções: Zig}
    \begin{lstlisting}[language=C]
const OptionalInt = ?i32;

const PtrToOneInt = *i32;

const PtrToManyInt = [*]i32;

const NullablePtrToOneInt = ?*i32;

const PtrToOneOptionalInt = *?i32;

const NullablePtrToManyInt = ?[*]i32;

const PtrToManyOptionalInt = [*]?i32;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Outros: Zig}
    \begin{lstlisting}[language=C]
// struct { len : usize, data : [*]i32, };
const Slice = []i32;

// Tem valores no array ate achar um A
// A eh um valor de i32
const Sentinel = [*:A]i32;

const CharStar = [*:0]u8;
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Implementação (Tipos Paramétricos)}
\end{frame}

\section{Classes de Tipos}
\begin{frame}
    \frametitle{Classes de Tipos}
    Outros nomes:
    \begin{itemize}
        \item Concepts [C++20]
        \item Interface [Go, Java, Kotlin, TypeScript]
        \item Module System [Standard ML]
        \item Mixin (?) [Ruby]
        \item Protocol [Erlang, Elixir, Swift]
        \item Typeclasses [Haskell]
        \item TypeTraits (?) [C++/Boost]
        \item Type Constrains [D]
        \item Traits [Rust]
        \item Vtable/Function Pointers [C, C++, Zig]
    \end{itemize}
    \vfill
    ``Concepts vs Typeclasses vs Traits vs Protocols''
    \url{youtu.be/E-2y1qHQvTg}
\end{frame}

\subsection{Monoid}
\begin{frame}
    \frametitle{Monoid}
\end{frame}

\subsection{Funtores}
\begin{frame}
    \frametitle{Funtores}
\end{frame}

\subsection{Monad}
\begin{frame}
    \frametitle{Monad}
\end{frame}

\begin{frame}
    \frametitle{Implementação (Classe de Tipos)}
\end{frame}

\section{Outros Tipos}
\begin{frame}
    \frametitle{Outros Tipos (Fora do escopo)}
\end{frame}

\subsection{Tipos Dependentes}
\begin{frame}
    \frametitle{Tipos Dependentes}
\end{frame}

\subsection{Tipos Lineares}
\begin{frame}
    \frametitle{Tipos Lineares}
\end{frame}

\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\begin{frame}
    \frametitle{FIM}
\end{frame}

\end{document}

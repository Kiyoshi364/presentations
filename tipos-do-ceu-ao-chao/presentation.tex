\documentclass{beamer}

\usepackage[brazil]{babel}
\usepackage[T1]{fontenc}
\usepackage[utf8]{inputenc}

\usepackage{listings}

\usepackage{hyperref}
\hypersetup{
    colorlinks=true,
    linkcolor=blue,
    urlcolor=red,
}

\usepackage{multicol}

\usetheme{Hannover}
\usecolortheme{crane}

\newcommand{\lang}[1]{\texttt{#1}}
\newcommand{\inlcode}[1]{\texttt{#1}}

\newcommand{\nota}[1]{\textbf{Nota:}\textit{ #1}}

\renewcommand{\d}{\:.\:}

% Tipos {
\newcommand{\typetam}{\#}
\newcommand{\typeeq}{\equiv}
\newcommand{\typesim}{\simeq}
% }

\newcommand{\tabelasizealign}{%
    \begin{tabular}{|c|c|c|}%
        \hline%
        Tipo & sizeof & alignment \\\hline%
        \hline%
        bool & 1      & 1         \\\hline%
        u32  & 4      & 4         \\\hline%
        u64  & 8      & 8         \\\hline%
    \end{tabular}%
}

\title{Tipos do Céu ao Chão}
\author{Hashimoto}
\date{17 de Junho de 2022}

\begin{document}

\begin{frame}
    \titlepage
\end{frame}

\begin{frame}
    \frametitle{ToC}
    \tableofcontents[hideallsubsections]
\end{frame}

\section{Tipos}
\begin{frame}
    \frametitle{Intro}
\end{frame}

\begin{frame}
    \frametitle{Notação}
    Alto nível:
    \begin{itemize}
        \item Tamanho de um tipo: \(\typetam(A)\)
        \item Dois tipos são iguais: \( A \typeeq B \)
        \item Dois tipos são isomorficos (equivalentes):
            \( A \typesim B \)
        \item Função que recebe \(A\), \(B\), \(C\),
            e retorna \(D\): \[ A \to B \to C \to D \]
    \end{itemize}

    Baixo nível:
    \begin{itemize}
        \item Inteiro com sinal de \(n\) bits: \(i\_n\)
        \item Inteiro com sinal de \(32\) bits: \(i32\)
        \item Inteiro sem sinal de \(n\) bits: \(u\_n\)
        \item Inteiro sem sinal de \(32\) bits: \(u32\)
        \item Booleano de tamanho byte: \(bool\)
            \\\nota{\(bool \typesim u1\)}
    \end{itemize}
\end{frame}

\section{Tipos - Caso Recursivo}
\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\subsection{Produto}
\begin{frame}
    \frametitle{Produto \(A \times B\)}
    \begin{itemize}
        \item Construtor
            \[
                A \to B \to A \times B
            \]
            \vfill
        \item Destrutor (projeções)
            \[
                \pi_A : A \times B \to A
            \] \[
                \pi_B : A \times B \to B
            \]
            \vfill
        \item Valores
            \[
                \typetam(A \times B) = \typetam(A) \times \typetam(B)
            \]
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Corolário}
    \begin{itemize}
        \item É associativo:
            \[
                (A \times B) \times C \typesim A \times (B \times C)
            \]
            \vfill
        \item É comutativo:
            \[
                (A \times B) \typesim (B \times A)
            \]
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: \(A \times B\)}
    \begin{itemize}
        \item \lang{C} \emph{(Struct)}:
            \begin{lstlisting}[language=C]
struct ProdutoIntDouble {
    int a;
    double b;
};
            \end{lstlisting}
        \item \lang{Java} \emph{(Class)} (*):
            \begin{lstlisting}[language=Java]
class ProdutoIntDouble {
    private int a;
    private double b;
}
            \end{lstlisting}
        \item \lang{Haskell} \emph{(Record)}:
            \begin{lstlisting}[language=Haskell]
data ProdutoIntDouble = PIntDouble
    { a :: Int
    , b :: Double
    }
            \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Matemática de Struct}
    Informações importantes de uma \emph{struct}:
    \begin{itemize}
        \item Tamanho \emph{(sizeof)}:
            quantos bytes ocupa?
        \item Alinhamento \emph{(alignment)}:
            endereço é múltiplo de quanto?
    \end{itemize}
    \vfill
    \nota{Nem sempre o \emph{tamanho final}
        é a soma dos \emph{tamanhos}!}
    \vfill
    Alinhamento:
    \url{www.delftstack.com/howto/c/struct-alignment-in-c/}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: Matemática de Struct}
    \begin{multicols}{2}
        \begin{lstlisting}[language=C]
struct Exemplo1 {
    u32 a;
    u32 b;
};
        \end{lstlisting}
        \begin{lstlisting}[language=C]
struct Exemplo2 {
    u32 a;
    bool b;
};
        \end{lstlisting}
        \begin{lstlisting}[language=C]
struct Exemplo3 {
    u64 a;
    u32 b;
    u32 c;
};
        \end{lstlisting}
        \columnbreak
        \begin{lstlisting}[language=C]
struct Exemplo4 {
    u32 b;
    u64 a;
    u32 c;
};
        \end{lstlisting}
        \begin{lstlisting}[language=C]
struct Exemplo5 {
    u32 b; u32 pad1;
    u64 a;
    u32 c; u32 pad2;
};
        \end{lstlisting}
        \tabelasizealign{}
    \end{multicols}
\end{frame}

\begin{frame}
    \frametitle{Respostas: Matemática de Struct}
    \begin{center} \begin{tabular}{|c|c|c||c|}
        \hline%
        Tipo      & sizeof & alignment & waste \\\hline
        \hline
        bool      & 1      & 1         & 0     \\\hline
        u32       & 4      & 4         & 0     \\\hline
        u64       & 8      & 8         & 0     \\\hline
        \hline
        Exemplo1  & 8      & 4         & 0     \\\hline
        Exemplo2  & 8      & 4         & 3     \\\hline
        Exemplo3  & 16     & 8         & 0     \\\hline
        Exemplo4  & 24     & 8         & 8     \\\hline
        Exemplo5  & 24     & 8         & 0     \\\hline
    \end{tabular} \end{center}
\end{frame}

\subsection{Soma}
\begin{frame}
    \frametitle{Soma \(A + B\)}
    \begin{itemize}
        \item Construtores
            \[
                left : A \to A + B
            \] \[
                right : B \to A + B
            \]
            \vfill
        \item (Família de) Destrutor(es)
            \[
                \forall x \d
                A + B \to (A \to x) \to (B \to x) \to x
            \]
            \vfill
        \item Valores
            \[
                \typetam(A + B) = \typetam(A) + \typetam(B)
            \]
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Corolário}
    \begin{itemize}
        \item É associativo:
            \[
                (A + B) + C \typesim A + (B + C)
            \]
            \vfill
        \item É comutativo:
            \[
                (A + B) \typesim (B + A)
            \]
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Unions}
    Em \lang{C}, temos \emph{Unions}!
    \vfill
    \begin{multicols}{2}
        \begin{lstlisting}[language=C]
union quase_soma {
    int a;
    float b;
    char c;
};
        \end{lstlisting}
        \columnbreak
        \nota{Depois que criamos um elemento da \inlcode{union}
        perdemos a informação de qual caso ele representa!}
    \end{multicols}
    \vfill
    Isso aloca um espaço na memória que pode armazenar
    um \inlcode{int} ou(-exclusivo)
    um \inlcode{float} ou(-exclusivo)
    um \inlcode{char}.
    \vfill
    O \emph{sizeof} é o
    \(\max(sizeof(int), sizeof(float), sizeof(char))\).
    \\
    O \emph{alignment} é o
    \(\max(align(int), align(float), align(char))\).
\end{frame}

\begin{frame}[fragile]
    \frametitle{Enums}
    Em \lang{C}, também temos \emph{Enums}!
    \vfill
    \begin{lstlisting}[language=C]
enum casos_soma {
    CASO_SOMA_A, CASO_SOMA_B, CASO_SOMA_C,
};
    \end{lstlisting}
    \vfill
    Isso dá ``um nome'' para alguns inteiros de \(0\) até \(2^n-1\)
    (em \lang{C} \(n := 32\),
    mas a princípio pode ser qualquer potência de \(2\))
    \vfill
    O \emph{sizeof} é o \(sizeof(un)\)
    (no caso do \lang{C} é \(sizeof(u32)\)).
    \\
    O \emph{alignment} é o \(align(un)\)
    (no caso do \lang{C} é \(align(u32)\)).
\end{frame}

\begin{frame}[fragile]
    \frametitle{Tagged Unions}
    Agora podemos juntar as duas!
    \vfill
    \begin{lstlisting}[language=C]
enum casos_soma {
    CASO_SOMA_A, CASO_SOMA_B, CASO_SOMA_C,
};

union quase_soma {
    int a; float b; char c;
};

struct soma {
    union quase_soma val;
    enum casos_soma tag;
};
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Tagged Unions}
    Equivalente!
    \vfill
    \begin{lstlisting}[language=C]
struct soma {
    union quase_soma {
        int a; float b; char c;
    } val;

    enum casos_soma {
        CASO_SOMA_A, CASO_SOMA_B,
        CASO_SOMA_C,
    } tag;
};
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Matemática de Tagged Union}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: \(A + B\)}
    \begin{itemize}
        \item \lang{Zig} \emph{(Tagged Union)}:
            \begin{lstlisting}[language=C]
const UnionIntDouble = union(enum) {
    caso_int: u32,
    caso_double: f64,
};
            \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: \(A + B\)}
    \begin{itemize}
        \item \lang{Java} \emph{(Dynamic Dispatch)} (*):
            \begin{lstlisting}[language=Java]
abstract class UnionBase {}

class UnionInt extends UnionBase {
    private int val;
}

class UnionDouble extends UnionBase {
    private double val;
}
            \end{lstlisting}
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Exemplos: \(A + B\)}
    \begin{itemize}
        \item \lang{Rust} \emph{(Enum)}:
            \begin{lstlisting}[language=C]
enum UnionIntDouble {
    CasoInt(i32),
    CasoDouble(f64)
}
            \end{lstlisting}
        \item \lang{Haskell} \emph{(Algebraic Data Type)}:
            \begin{lstlisting}[language=Haskell]
data UnionIntDouble
    = CasoInt Int
    | CasoDouble Double
            \end{lstlisting}
    \end{itemize}
\end{frame}

\subsection{Exponencial}
\begin{frame}
    \frametitle{Exponencial \(B^A\)}
    \begin{itemize}
        \item Construtor
            \[
                (A \to B) \to B^A
            \]
            \vfill
        \item Destrutor
            \[
                eval : B^A \to A \to B
            \]
            \vfill
        \item Valores
            \[
                \typetam\left(B^A\right) = \typetam(B)^{\typetam(A)}
            \]
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Exponencial \(B^A\)}
    Opções de implementação:
    \begin{itemize}
        \item Look-up Table (Arrays)
            \begin{itemize}
                \item Memória:
                    \(sizeof(B) \times \typetam(A)\)
                    \par
                    \nota{Precisa converter \(A\) para inteiro}
            \end{itemize}
        \vfill
        \pause
        \item Ponteiros para função:
            \begin{itemize}
                \item Memória:
                    \emph{código} (estático)
                    + \emph{ponteiro} (cada instância)
            \end{itemize}
        \vfill
        \pause
        \item (Código de uma) Máquina Virtual
        \vfill
        \pause
        \item ??? (Céu é o limite)
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Por que \(B^A\)?}
    Um grande motivo é \emph{Programação Funcional}:
    \begin{itemize}
        \item Receber/Passar uma função
        \item Closures
        \item Aplicação Parcial
        \item Callbacks
    \end{itemize}
    \vfill
    \pause
    Também serve como base para
    \emph{Virtual Tables} \emph{(Vtables)}:
    \begin{itemize}
        \item Intefaces
        \item Dynamic Dispatch
    \end{itemize}
\end{frame}

\section{Tipos - Casos Base}
\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\subsection{Unity}
\begin{frame}
    \frametitle{\(()\)}
\end{frame}

\subsection{Void}
\begin{frame}
    \frametitle{\(Void\)}
\end{frame}

\subsection{Bool}
\begin{frame}
    \frametitle{Bool}
\end{frame}

\subsection{Int}
\begin{frame}
    \frametitle{I32}
\end{frame}

\section{Tipos Paramétricos}
\begin{frame}
    \frametitle{Tipos Paramétricos}
    Outros nomes:
    \begin{itemize}
        \item Generics [Java]
        \item Macros (*) [C]
        \item Meta Programming (Comptime) [Zig]
        \item Templates (typename) [C++]
    \end{itemize}
\end{frame}

\subsection{Maybe}
\begin{frame}
    \frametitle{Maybe a}
\end{frame}

\subsection{Either}
\begin{frame}
    \frametitle{Either a b}
\end{frame}

\subsection{List}
\begin{frame}
    \frametitle{[a]}
\end{frame}

\begin{frame}[fragile]
    \frametitle{int *p = \&i;}
    \begin{lstlisting}[language=Haskell]
Pointer a = Null
    | Estrela  a
    | Colchete [a]
    \end{lstlisting}
    \vfill
    Problemas (teóricos) dessa representação:
    \begin{itemize}
        \item
            \texttt{C} não sabe diferenciar
            \texttt{Estrela} e \texttt{Colchete}
        \item
            Temos que checar se é \texttt{Null} o tempo todo
        \item
            \textbf{Invisível:} no caso \texttt{Colchete},
            podemos não saber o tamanho da lista
            \par
            \nota{ainda podemos ter o ``null terminator''
            ou guardar um tamanho externo}
        \item
            Na prática, só queremos usar
            \texttt{Estrela} ou \texttt{Colchete}
            \par
            \nota{o ``ou'' é exclusivo}
        \item
            Mais alguns (específicos sobre implementação) \dots
    \end{itemize}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Soluções: Zig}
    \begin{lstlisting}[language=C]
const OptionalInt = ?i32;

const PtrToOneInt = *i32;

const PtrToManyInt = [*]i32;

const NullablePtrToOneInt = ?*i32;

const PtrToOneOptionalInt = *?i32;

const NullablePtrToManyInt = ?[*]i32;

const PtrToManyOptionalInt = [*]?i32;
    \end{lstlisting}
\end{frame}

\begin{frame}[fragile]
    \frametitle{Outros: Zig}
    \begin{lstlisting}[language=C]
// struct { len : usize, data : [*]i32, };
const Slice = []i32;

// Tem valores no array ate achar um A
// A eh um valor de i32
const Sentinel = [*:A]i32;

const CharStar = [*:0]u8;
    \end{lstlisting}
\end{frame}

\begin{frame}
    \frametitle{Implementação (Tipos Paramétricos)}
\end{frame}

\section{Classes de Tipos}
\begin{frame}
    \frametitle{Classes de Tipos}
    Outros nomes:
    \begin{itemize}
        \item Concepts [C++20]
        \item Interface [Go, Java, Kotlin, TypeScript]
        \item Module System [Standard ML]
        \item Mixin (?) [Ruby]
        \item Protocol [Erlang, Elixir, Swift]
        \item Typeclasses [Haskell]
        \item TypeTraits (?) [C++/Boost]
        \item Type Constrains [D]
        \item Traits [Rust]
        \item Vtable/Function Pointers [C, C++, Zig]
    \end{itemize}
    \vfill
    ``Concepts vs Typeclasses vs Traits vs Protocols''
    \url{youtu.be/E-2y1qHQvTg}
\end{frame}

\subsection{Monoid}
\begin{frame}
    \frametitle{Monoid}
\end{frame}

\subsection{Funtores}
\begin{frame}
    \frametitle{Funtores}
\end{frame}

\subsection{Monad}
\begin{frame}
    \frametitle{Monad}
\end{frame}

\begin{frame}
    \frametitle{Implementação (Classe de Tipos)}
\end{frame}

\section{Outros Tipos}
\begin{frame}
    \frametitle{Outros Tipos}
    Existem mais tipos!
    \vfill
    Mas infelizmente não dá tempo de falar sobre todos eles
    \texttt{:(\phantom)}
    \vfill
    Vou passar rapidinho por eles.
\end{frame}

\begin{frame}
    \frametitle{Tipos Dependentes}
    Permite criar \emph{tipos} que dependem de \emph{valores}
    \vfill
    Útil para dar tipos para: \texttt{arrays}, \emph{provas}, \dots
    \vfill
    \begin{columns}
        \column{0.5\textwidth}
            Linguagens de programação:
            \begin{itemize}
                \item Agda
                \item C++ [Template]
                \item Idris
            \end{itemize}
        \column{0.5\textwidth}
            Assistentes de Prova:
            \begin{itemize}
                \item ALF
                \item Coq
                \item Lean
            \end{itemize}
    \end{columns}
    \vfill
    Mais exemplos:
    \url{en.wikipedia.org/wiki/Category:Dependently_typed_languages}
\end{frame}

\begin{frame}
    \frametitle{Tipos Sub-estruturais}
    \only<1>{
        \begin{quote}
            Como assim, você está usando um ovo duas vezes???
            Você não pode fazer dois bolos e só usar um ovo!!!
        \end{quote}
    } \only<2-> {
        \begin{center} \begin{tabular}{|c|c|c|c|}
            \hline
                     & Exchange & Weakening & Contraction \\\hline
            \hline
            Ordered  & Não      & Não       & Não         \\\hline
            Linear   & Sim      & Não       & Não         \\\hline
            Affine   & Sim      & Sim       & Não         \\\hline
            Relevant & Sim      & Não       & Sim         \\\hline
            Normal   & Sim      & Sim       & Sim         \\\hline
        \end{tabular} \end{center}
        \nota{Existe uma lógica para cada linha da tabela.}
        \vfill
        \only<2> {
            Usos:
            \begin{itemize}
                \item Ordered: Alocação em Stack
                \item Linear: Uso de recursos (exatamente uma vez)
                \item Affine: Uso de recursos (zero ou uma vez)
                \item Relevant: Uso de recursos (uma ou mais vezes)
            \end{itemize}
        } \only<3> {
            Linguagens de programação (Linear/Affine):
            \begin{itemize}
                \item Idris
                \item Linear ML
                \item Rust [Borrow-checker, Copy Trait]
                \item Nim
            \end{itemize}
        }
        \vfill
        Ref: \url{en.wikipedia.org/wiki/Substructural_type_system}
    }
\end{frame}

\begin{frame}
    \frametitle{Efeitos Algébricos (\emph{*novo*})}
    São \texttt{exceptions} (\texttt{exceções}),
    porém mais \emph{gerais}.
    \vfill
    Os \texttt{handlers} (algo tipo os blocos \texttt{catch})
    podem continuar a função que gerou a exceção e
    modificar a saída.
    \vfill
    Linguagens de programação (de pesquisa):
    \begin{itemize}
        \item Eff (\url{eff-lang.org})
        \item Effekt (\url{effekt-lang.org})
        \item Koka (\url{koka-lang.github.io})
        \item Unison (\url{unison-lang.org/})
    \end{itemize}
    \vfill
    Ref: \url{en.wikipedia.org/wiki/Effect_system}
\end{frame}

\begin{frame}
    \frametitle{Placeholder}
\end{frame}

\begin{frame}
    \frametitle{FIM}
\end{frame}

\end{document}
